#!/usr/bin/env python3

import re
import argparse
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

'''
Create a list of file paths of the outputs generated by `translate_ddG.py`.
Pass that list as --input argument.
The files output from that script should look like this:

`output/20251005_deltaGoutput/20251005-184439_ddGout_sepmcsp16-13_model/out_energies.csv`:
DesignNum,PeptideSequence,bound_dG,unbound_dG,ddG
0,TGGRLGNRSGTQALGK,-993.2077853755554,-967.6941463143296,-25.51363906122583

If there were rosetta-designed sequences, they appear in the same csv as more rows. 
This plotting script will only ever use the first row.
'''

def ddGs_to_dataframe(file_list: list, targets: list, 
                      re_beginning: str, re_end: str, re_group: str = '_'):
    '''
    Produce a pandas DataFrame of the ddG outputs from multiple replicate 
    outputs of `translate_ddG.py`. Uses regex in file strings to detect which
    peptide and which target. 
    Output DataFrame has columns: 'Peptide', 'ddG (REU)', 'Target'

    PARAMETERS: 
    file_list: list     List of string addresses of all files. These paths
                        should be similarly formatted with the target protein
                        name directly preceding the name of the peptide. 
    targets: list       Names of target proteins.
    re_beginning: str   Regex string for first part of the file path to trim.
                        Must end in '_'.
    re_end: str         Regex string for last part of the file path to trim.
    re_group: str       Separator for the sample+replicate name. 
                        Default = '_' (<samplename>_<replicatename>)
    '''
    assert re_beginning[-1] == '_'
    ddGs = pd.DataFrame(columns=['Peptide', 'ddG (REU)', 'Target', 'Filename'])

    for file in file_list: 
        # regex shorten file path to get unique replicate name 
        name = re.sub('^.*{}|{}.*$'.format(re_beginning, re_end), '', file)
        # get non-unique name of replicates
        peptide_name = re.match('^[^{}]*'.format(re_group), name).group(0)
        
        target = 'Not found'
        for t in targets: 
            if t in name: 
                target = t
                # remove target name and spacer chars from front of peptide name
                for char in [t, '-', '_']:
                    peptide_name = peptide_name.removeprefix(char)
                break

        df = pd.read_csv(file) #1st row, 5th col has ddG
        new_row = pd.DataFrame({'Peptide': [peptide_name], 
                                'ddG (REU)': [df.iloc[0,4]], 
                                'Target': [target],
                                'Filename': [file] }) 
        ddGs = pd.concat([ddGs, new_row])
    return ddGs

def plot_boxes_from_df(data_frame):
    '''
    Plots boxes colored for each target, grouped by peptide.
    '''
    sorted_data = data_frame.sort_values(by='Peptide', ascending=False)

    plt.clf()
    plt.subplots(figsize=(12, 6))
    sns.boxplot(data=sorted_data, x='Peptide', y='ddG (REU)', hue='Target') 
    plt.title('Delta Delta G: CSP variants')
    plt.savefig("ddG_figure_boxes.pdf", format="pdf")

def main():
    parser = argparse.ArgumentParser(description="")
    parser.add_argument("--input", "-i", type=str, default="inputs_to_plot.txt", 
                        help="Path to input txt containing list of files to gather data from.")
    parser.add_argument("--per-residue", type=str, default="",
                        help="Rosetta REU score per residue. If specified, this file path contains peptide names and their corresponding lengths in csv. First column is peptide name as in file names, second column is integer lengths. Do not include header.")
    args = parser.parse_args()

    file_list = pd.read_csv(args.input, header = None)[0].to_list()
    ddGs = ddGs_to_dataframe(file_list, ["comdn230", "sepm"], "ddGout_", "_model", "_", )
    
    if args.per_residue != "": 

        pep_lengths = dict()
        with open(args.per_residue, 'r') as lengths_in:
            for line in lengths_in: 
                splitline = line.strip().split(',')
                pep_lengths[splitline[0]] = int(splitline[1])

        # normalize scores of ddGs
        def norm_by_len(dfrow): 
            return dfrow['ddG (REU)'] / pep_lengths[dfrow['Peptide']]
        ddGs['ddG (REU)'] = ddGs.apply(norm_by_len, axis=1) 
        
        # write per residue ddG
        ddGs.to_csv("all_ddGs_perresidue.csv")
    else: 
        # write ddGs without calculating per residue ddG
        ddGs.to_csv("all_ddGs.csv")

    plot_boxes_from_df(ddGs)

if __name__ == "__main__":
    main()
